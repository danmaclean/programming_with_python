[
["index.html", "Beginning Python For Programming Chapter 1 Prerequisites 1.1 Installing Python 3 with Anaconda 1.2 Starting a Jupyter Notebook 1.3 Installing Python Packages with conda", " Beginning Python For Programming Dan MacLean 2018-12-14 Chapter 1 Prerequisites No specific knowledge is assumed for this book, though you do need to install some software. Python 3 via Anaconda A reasonably recent web-browser The PyVCF and biopython python packages The file example.vcf and SRR020192.fastq.gz 1.1 Installing Python 3 with Anaconda Follow this link and install Python 3.x for your operating system. https://www.anaconda.com/distribution/ 1.1.1 Note for macOS users Accept all of the defaults during installation Here is a video tutorial https://www.youtube.com/watch?v=TcSAln46u9U 1.1.2 Note for Windows users Install Python 3 using all of the defaults for installation except make sure to check Add Anaconda to my PATH environment variable. Here is a video tutorial https://www.youtube.com/watch?v=xxQ0mzZ8UvA 1.1.3 Note for Linux Users You’ll need to be able to use the command-line to install with Anaconda. If you aren’t comfortable with this, ask for assistance from the local support team. Open https://www.anaconda.com/download/#linux with your web browser. Download the Python 3 installer for Linux. Open a terminal window. 4.Type bash Anaconda3-and then press Tab. The name of the file you just downloaded should appear. If it does not, navigate to the folder where you downloaded the file, for example with: cd Downloads. Then, try again. Press enter. You will follow the text-only prompts. To move through the text, press the spacebar. Type yes and press enter to approve the license. Press enter to approve the default location for the files. Type yes and press enter to prepend Anaconda to your PATH (this makes the Anaconda distribution the default Python). Close the terminal window. 1.2 Starting a Jupyter Notebook 1.2.1 macOS Start the Terminal application in Applications -&gt; Utilities Type jupyter notebook, it should start in your web browser 1.2.2 Windows From the Start menu, search for and open Anaconda 3 or Jupyter Notebook. You should be able to start a notebook directly by clicking the Jupyter Notebook icon. 1.2.3 Linux Open the terminal application. It is usually in the task bar or dock Type jupyter notebook, it should start in your web browser 1.3 Installing Python Packages with conda You can use conda to install new Python packages with conda install &lt;package_name&gt;. You can install the required packages with conda install PyVCF conda install biopython Accept all defaults when the system asks a question. "],
["motivation.html", "Chapter 2 Motivation", " Chapter 2 Motivation Programming is a pretty weird skill. It boils down to shouting at a computer to make it do stuff for you. So why would you want to learn to do it? Well, there are plenty of reasons, some good and some bad. Some good ones that apply to working in biology and bioinformatics are time-saving, turning your computer from a limited ‘appliance’ to a general ‘power tool’ for your research and because it’s a skill that can help you develop a more precise, disciplined and abstract way of thinking. The main obstacle that most people encounter when learning to program is the surprisingly wide range of facts that you need to know in order to achieve something. This can make it The aim of this course is to introduce you to just enough of these facts and tricks to enable you to do useful stuff with programming. The things you’ll learn here will seem quite abstract and disconnected at first but hopefully by the end of the course you’ll be able to string them together to make something useful - and understand what’s going on. In this course, we’ll use Python 3 as our programming language - it’s a widely used very powerful but (all things considered) user-friendly language that suits beginners and experts alike (well, as well as any programming language can suit human users). We’ll use the bare-bones of Python 3, it is a very broad language with a lot of functionality, a lot of it in optional packages that you can install at will. We’ll only touch the surface of what you can do - but what we learn will be foundation enough to build pretty much anything on. "],
["data.html", "Chapter 3 Working with Data 3.1 Using variables as names for data 3.2 Functions from different places 3.3 Objects and types in Python 3.4 Quiz", " Chapter 3 Working with Data Questions: How do I deal with data in Python? Objectives: Defining variables and using them in functions Using simple data objects: strings and numbers Using package functions and object methods Keypoints: variables are handy names for data objects variables are used in functions functions can be stored in packages methods available depend on the object we’re talking about In any Python program we will have some data and some objective to achieve - something to do with that data. Python provides many data types and many ways of working with that data. Let’s see the simplest example of this, let’s take a string (a text carrying data type) and use it in a function. print(&quot;Hello, world!&quot;) ## Hello, world! In this example is the text &quot;Hello, World!&quot;, is being given to the print() function. Functions are bits of code that do stuff to data. The print() function just prints the data you pass it to the screen. We pass data to functions by putting the data in the brackets after the function name. print() just tries to print the data you give it to the screen. 3.1 Using variables as names for data We don’t usually use data as directly as this. Instead we use a name that refers to a piece of data - a variable. Variables are just names that represent a bit of data. It’s called a variable because the data the variable is associated with can change. We assign a name to data by using the assignment symbol the = sign. The data associated with a variable can be changed by re-assignment. allowing us to reuse the name. We can use variables as if they were the data they point to x = &quot;Hello, world!&quot; print(x) ## Hello, world! x = 100 print(x) ## 100 And variables are independent of one another, actions on one don’t affect another weight_kg = 65 weight_pounds = 2.2 * weight_kg print(weight_kg) ## 65 print(weight_pounds) ## 143.0 3.2 Functions from different places We can work on data objects in Python using three different types of function Object Methods Built-In Functions and Operators Package Functions 3.2.1 Built-In Functions and Operators Python has some functions that can be called directly from anywhere in a program. These are listed here https://docs.python.org/3.3/library/functions.html. We’ve already seen print() `and there are some common ones we’ll come across later. You can spot a built-in function because it has a single-word name followed by brackets. Related to built-in functions are operators. The things you’ll use most are the mathematical operators that work as you would expect from your knowledge of maths. So they include things like, + , -, *, / etc. print(1 + 1) ## 2 print(2 * 2) ## 4 print(3 - 3) ## 0 print(4 / 4) ## 1.0 Some operators change what they do depending on the things you ask them to operate on. For instance, we can add strings?! print( &quot;Hello&quot; + &quot;World!&quot;) ## HelloWorld! 3.2.2 Package Methods Another source of functions is external packages - extensions to Python for use in particular problem domains. We can load in a package using import. Let’s import the numpy numerical Python package that provides functions for doing fast, large scale numerical analysis. import numpy We can access the functions in this package by using the package name and the dot (.) syntax and the function name. Let’s call the numpy function arange() which gives us a list of numbers. numbers = numpy.arange(10) print( numbers ) ## [0 1 2 3 4 5 6 7 8 9] 3.2.3 Object Methods Python’s data are represented in the computer in things called objects. An object is basically a bit of data with some functions attached. So that each piece of data comes with the code to manipulate it. These attached functions are called methods. We access data’s methods using the . syntax, so you have variable_name.method(), read this as you telling the variable to do method() to itself, so a text containing variable x used with .capitalize() comes to x = &quot;hello, world!&quot; print( x.capitalize() ) ## Hello, world! This does mean that the methods are closely tied to the data. Look what happens when we try to use .capitalize() on a number y = 100 print( y.capitalize() ) Error in py_run_string_impl(code, local, convert) : AttributeError: &#39;int&#39; object has no attribute &#39;capitalize&#39; Python just throws an error. Basically this error is saying that int (integer, a number object ) doesn’t have a method called capitalize. We need to know what methods an object has before we can work on them. We can find this by reading the documentation for the object type. And Python will give us the type with the type() function print( type(x) ) ## &lt;class &#39;str&#39;&gt; We can see that x contains a str - a string. The easiest place to find the Python documentation is online. Googling Python 3 str shows us this page https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str, which shows us all the String methods. This works well for finding all methods for objects of other types. 3.3 Objects and types in Python Python knows many types of object, most things are an object of some type. Three common object types are: strings integer numbers floating point numbers 3.3.1 String Objects The term ’strings` is computer jargon for text data, usually a single lump of text data treated as a whole. And to create a strings we simply have to add single or double quotes around some text, for example: weight_kg_text = &#39;weight in kilograms&#39; Having actual numbers in there doesn’t make a string a number type - the following is still a string - it just happens to be made up of number like characters. Let’s see what happens if we try and treat it like a number. phone_number = &quot;01818118181&quot; print( phone_number * 2 ) ## 0181811818101818118181 Here the * operator has modified itself to work on a string and repeated the string! 3.3.1.1 Indexing a string (Slicing) We can access a single character in a string using indexing - basically asking for a character at a position. The syntax uses the square brackets. print( phone_number[2] ) ## 8 Note that using the index [2] gives us the third character - computer languages tend to count from 0. We can get a longer subsection of a string using indexing as well - this is a technique that accesses a part of the data given a start and end point along the string. dialling_code = phone_number[0:3] print(dialling_code) ## 018 We just use the square brackets to indicate the start and stop points of the slice we want to extract, literally [start:end]. The start here is 0 meaning the first character, the end here is 3, but it means up to but not including the end. print( dialling_code ) ## 018 That’s why we only get the first three characters from the string and not 4 ie 0,1,2,3. The way to remember this is that the length of the resulting slice is end - start. There are many string operations and methods, you can see them in the documentation at https://docs.python.org/3/library/stdtypes.html#textseq 3.3.2 Number Objects Numbers in Python come in two types, whole numbers (called integers) and numbers with a decimal part (called floating point numbers). In the example above, variable weight_kg has an integer value of 65. To create a variable with a floating point value, we can execute: weight_kg = 65.0 The difference is important. Operations with integers return only integers. print( 10 / 3 ) ## 3.3333333333333335 Operations with floating points return floating points print( 10.0 / 3.0 ) ## 3.3333333333333335 print( 10 / 3.0 ) ## 3.3333333333333335 print( 10.0 / 3) ## 3.3333333333333335 You can convert type explicitly using the int() and float() functions. print( float(10) / 3 ) ## 3.3333333333333335 print( int( 10.0 / 3.0 ) ) ## 3 3.4 Quiz What values do the variables mass and age have after each statement in the following program? Test your answers by executing the commands. mass = 47.5 age = 122 mass = mass * 2.0 age = age - 20 What does the following program print out? first, second = &#39;Grace&#39;, &#39;Hopper&#39; third, fourth = second, first print(third, fourth) Recall that a section of string is called a slice. element = &#39;oxygen&#39; print(&#39;first three characters:&#39;, element[0:3]) print(&#39;last three characters:&#39;, element[3:6]) What is the value of element[:4]? What about element[4:]? Or element[:]? What is element[-1]? What is element[-2]? Given those answers, explain what element[1:-1] does. Fix the capitalisation in messy_string messy_string = &quot;OH mY, ThESE LEtters Are ALL OVER The PLace!&quot; Hint: Think about standardising the letters by e.g making all one case, then fixing the capitalization from there. Check out the math package. https://docs.python.org/3/library/math.html and import it. What is the arc sine of -1, 0, 1 in radians? How many degrees in \\(\\arcsin(-1)\\) radians? "],
["data-structures.html", "Chapter 4 Data Structures 4.1 Lists 4.2 Dictionaries 4.3 Quiz", " Chapter 4 Data Structures Questions: How do I arrange and process lots of data in Python? Objectives: Create and work with lists and dicts Using loops and conditionals to make decisions Keypoints: variables are handy names for data objects variables are used in functions functions can be stored in packages methods available depend on the object we’re talking about 4.1 Lists Like most programming languages Python has some built in data structures that we can use. Data structures are collection types that group lots of data into a single object and make working with lots of data easier. The simplest data structure is a list. We can create a list simply by enclosing our data in square brackets. my_list = [1,3,5,7] print( my_list ) ## [1, 3, 5, 7] More often, though, we’ll get a list as the result of a function. Recall the numpy function we used earlier. import numpy numbers = numpy.arange(15) print( numbers ) ## [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14] 4.1.1 List use Lists can mix up any sort of data type, numbers_and_letters = [1,2, &#39;three&#39;, &#39;IV&#39;, 5.0 ] print( numbers_and_letters ) ## [1, 2, &#39;three&#39;, &#39;IV&#39;, 5.0] including other lists. list_of_lists = [ [1,2,3], [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] ] print( list_of_lists ) ## [[1, 2, 3], [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]] List elements can be accessed using indexing, like with strings. print( numbers_and_letters[0] ) ## 1 print( numbers_and_letters[2:3] ) ## [&#39;three&#39;] Indexing an element returns the whole element - so if that element happens to be a list itself - you get a whole list back print( list_of_lists[1] ) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] To get at a single element you must use double square brackets. print( list_of_lists[0][1] ) ## 2 print( list_of_lists[1][0] ) ## a 4.2 Dictionaries Another very common data structure is a dictionary. A dictionary is a data structure that has many unique keys, each of which refers to a bit of other data called a value. We can construct them using the curly brackets and the key/value pairs my_dict = { &quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot; } print( my_dict ) ## {&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;} Note the order in the dictionary isn’t preserved. We can use the square brackets to get a single value, but as a dictionary has no order or index, we must use the key. print( my_dict[&quot;key1&quot;] ) ## value1 Dictionaries are useful when you want to ask for a bit of data by some name, rather than by its position in a list. Dictionaries can hold anything in their values. But keys are restricted to particular datatypes. Strings and numbers are good keys, lists are not allowed. print( { [&quot;list_key&quot;, 1, 2] : [&quot;some data&quot;] } ) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; TypeError: unhashable type: &#39;list&#39; 4.3 Quiz Given the list below, use slicing to access only the last four entries. list_for_slicing = [[&quot;fluorine&quot;, &quot;F&quot;], [&quot;chlorine&quot;, &quot;Cl&quot;], [&quot;bromine&quot;, &quot;Br&quot;], [&quot;iodine&quot;, &quot;I&quot;], [&quot;astatine&quot;, &quot;At&quot;]] Can you work out how to correct the wrong data in the dictionary below? Try to think of a way that doesn’t involve re-writing the whole dictionary. Hint: can you assign straight to a key? seasons = { &#39;spring&#39; : [&#39;mar&#39;, &#39;apr&#39;, &#39;may&#39; ], &#39;autumn&#39; : [&#39;jun&#39;, &#39;jul&#39;, &#39;aug&#39;], &#39;winter&#39; : [&#39;dec&#39;, &#39;jan&#39;, &#39;feb&#39;] } Add in the missing season. "],
["making-choices-and-controlling-program-flow.html", "Chapter 5 Making Choices and Controlling Program Flow 5.1 Conditionals 5.2 Logical operators 5.3 That’s Not Not What I Meant 5.4 Quiz", " Chapter 5 Making Choices and Controlling Program Flow How can we use Python to automatically recognize differences in data such that it can change what code is run depending on the data and take a different action for each? In this chapter, we’ll learn how to write code that runs only when certain conditions are true. 5.1 Conditionals We can ask Python to take different actions, depending on a condition, with an if statement: num = 37 if num &gt; 100: print(&#39;greater&#39;) else: print(&#39;not greater&#39;) ## not greater The second line of this code uses the keyword if to tell Python that we want to make a choice. If the test that follows the if statement is true, the body of the if (i.e., the lines indented underneath it) are executed. If the test is false, the body of the else is executed instead. Only one or the other is ever executed: The diagram below shows how this choice is being made. Executing a Conditional Conditional statements don’t have to include an else. If there isn’t one, Python simply does nothing if the test is false: num = 53 print(&#39;before conditional...&#39;) ## before conditional... if num &gt; 100: print(num,&#39; is greater than 100&#39;) print(&#39;...after conditional&#39;) ## ...after conditional We can also chain several tests together using elif, which is short for “else if”. The following Python code uses elif to print the sign of a number. num = -3 if num &gt; 0: print(num, &#39;is positive&#39;) elif num == 0: print(num, &#39;is zero&#39;) else: print(num, &#39;is negative&#39;) ## -3 is negative Note that the if and elif bits are mutually exclusive. Only one of them ever gets executed. 5.1.1 Testing equality Note that to test for equality we use a double equals sign == rather than a single equals sign = which is already used to assign values. 5.2 Logical operators Python has all the standard logical operators that let us combine tests. Most commonly there is and and or. and is only true if both parts are true: if (1 &gt; 0) and (-1 &gt; 0): print(&#39;both parts are true&#39;) else: print(&#39;at least one part is false&#39;) ## at least one part is false while or is true if at least one part is true: if (1 &lt; 0) or (-1 &lt; 0): print(&#39;at least one test is true&#39;) ## at least one test is true 5.2.1 What is True and what is False True and False True and False are special words in Python called booleans, which represent truth values. A statement such as 1 &lt; 0 returns the value False, while -1 &lt; 0 returns the value True. True and False booleans are not the only values in Python that are true and false. In fact, any value can be used in an if or elif. After reading and running the code below, explain what the rule is for which values are considered true and which are considered false. if &#39;&#39;: print(&#39;empty string is true&#39;) if &#39;word&#39;: print(&#39;word is true&#39;) ## word is true if []: print(&#39;empty list is true&#39;) if [1, 2, 3]: print(&#39;non-empty list is true&#39;) ## non-empty list is true if 0: print(&#39;zero is true&#39;) if 1: print(&#39;one is true&#39;) ## one is true 5.3 That’s Not Not What I Meant Sometimes it is useful to check whether some condition is not true. The Boolean operator not can do this explicitly. After reading and running the code below, write some if statements that use not to test the rule that you formulated in the previous challenge. if not &#39;&#39;: print(&#39;empty string is not true&#39;) ## empty string is not true if not &#39;word&#39;: print(&#39;word is not true&#39;) if not not True: print(&#39;not not True is true&#39;) ## not not True is true 5.4 Quiz Consider this code: if 4 &gt; 5: print(&#39;A&#39;) elif 4 == 5: print(&#39;B&#39;) elif 4 &lt; 5: print(&#39;C&#39;) Which of the following would be printed if you were to run this code? Why did you pick this answer? A B C B and C Consider this code: if 4 &gt; 5: print(&#39;A&#39;) if 4 &lt;= 5: print(&#39;B&#39;) if 4 &lt; 5: print(&#39;C&#39;) Which of the following would be printed if you were to run this code? Why did you pick this answer? A B C B and C Consider this code: if 4 &gt; 5: print(&#39;A&#39;) elif 4 &lt;= 5: print(&#39;B&#39;) elif 4 &lt; 5: print(&#39;C&#39;) Which of the following would be printed if you were to run this code? Why did you pick this answer? A B C B and C "],
["repeating-actions-with-loops.html", "Chapter 6 Repeating actions with Loops 6.1 For Loops 6.2 While Loops 6.3 Quiz", " Chapter 6 Repeating actions with Loops To do that, we’ll have to teach the computer how to repeat things. An example task that we might want to repeat is printing each character in a word on a line of its own. We can access a character in a string using its index. For example, we can get the first character of the word 'lead', by using word[0]. One way to print each character is to use four print statements: word = &#39;lead&#39; print(word[0]) ## l print(word[1]) ## e print(word[2]) ## a print(word[3]) ## d This is a bad approach for two reasons: It doesn’t scale: if we want to print the characters in a string that’s hundreds of letters long, we’d be better off just typing them in. It’s fragile: if we give it a longer string, it only prints part of the data, and if we give it a shorter one,it produces an error because we’re asking for characters that don’t exist. word = &#39;tin&#39; print(word[0]) print(word[1]) print(word[2]) print(word[3]) --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-3-7974b6cdaf14&gt; in &lt;module&gt;() 3 print(word[1]) 4 print(word[2]) ----&gt; 5 print(word[3]) IndexError: string index out of range 6.1 For Loops Instead we can use a loop - a construct that moves through a collection of data taking one bit at a time. Here’s a loop in action word = &#39;lead&#39; for char in word: print(char) ## l ## e ## a ## d This is shorter, certainly shorter than something that prints every character in a hundred-letter string and more robust as well. See how the same code works if we change the length of the word word = &#39;oxygen&#39; for char in word: print(char) ## o ## x ## y ## g ## e ## n The improved version uses a for loop to repeat code in this case print(), once for each thing in a sequence. The general form of a loop is: Using the oxygen example above, the loop might look like this: loop_image where each character (char) in the variable word is looped through and printed one character after another. The numbers in the diagram denote which loop cycle the character was printed in (1 being the first loop, and 6 being the final loop). We can call the loop variable anything we like, but there must be a colon at the end of the line starting the loop, and we must indent anything we want to run inside the loop. Unlike many other languages, there is no command to signify the end of the loop body (e.g. end for); what is indented after the for statement belongs to the loop. 6.1.1 Choosing loop variable names In the example above, the loop variable was given the name char as a mnemonic; it is short for ‘character’. We can choose any name we want for variables. We might just as easily have chosen the name banana for the loop variable, as long as we use the same name when we invoke the variable inside word = &#39;oxygen&#39; for banana in word: print(banana) ## o ## x ## y ## g ## e ## n It is a good idea to choose variable names that are meaningful, otherwise it would be more difficult to understand what the loop is doing. Here’s another loop that repeatedly updates a variable: length = 0 for vowel in &#39;aeiou&#39;: length = length + 1 print(&#39;There are&#39;, length, &#39;vowels&#39;) ## There are 5 vowels It’s worth tracing the execution of this little program step by step.Since there are five characters in 'aeiou',the statement on line 3 will be executed five times.The first time around,length is zero (the value assigned to it on line 1) and vowel is 'a'. The statement adds 1 to the old value of length, producing 1, and updates length to refer to that new value. The next time around,vowel is 'e' and length is 1, so length is updated to be 2. After three more updates, length is 5; since there is nothing left in 'aeiou' for Python to process, the loop finishes and the print statement on line 4 tells us our final answer. 6.1.2 Loop variable lifespan Note that a loop variable is just a variable that’s being used to record progress in a loop. It still exists after the loop is over, and we can re-use variables previously defined as loop variables as well: letter = &#39;z&#39; for letter in &#39;abc&#39;: print(letter) ## a ## b ## c print(&#39;after the loop, letter is&#39;, letter) ## after the loop, letter is c Note also that finding the length of a string is such a common operation that Python actually has a built-in function to do it called len: print(len(&#39;aeiou&#39;)) ## 5 6.1.3 Looping over a range of numbers What if we don’t want to do every item in a collection, or if we want to do something a set number of times? We can create a collection that has the things we need. Python has a built-in function called range() that creates a sequence of numbers. range() can accept 1, 2, or 3 parameters. If one parameter is given, range creates an array of that length, starting at zero and incrementing by 1. For example, range(3) produces the numbers 0, 1, 2. If two parameters are given, range starts at the first and ends just before the second, incrementing by one. For example, range(2, 5) produces 2, 3, 4. If range is given 3 parameters, it starts at the first one, ends just before the second one, and goes up in steps of the third one. For example range(3, 10, 2) produces 3, 5, 7, 9. 6.2 While Loops A different sort of loop is the while loop. This loop repeats while something is in some state - usually the True state. i = 1 while i &lt; 6: print(i) i += 1 ## 1 ## 2 ## 3 ## 4 ## 5 The while loop is somewhat rare in Python, but does get used from time to time. 6.3 Quiz Using range, write a loop to print the first 3 natural numbers. Exponentiation is built into Python. Write a loop that calculates the same result as 5 ** 3 using multiplication (and without exponentiation). print(5 ** 3) ## 125 Knowing that two strings can be concatenated using the + operator, write a loop that takes a string and produces a new string with the characters in reverse order, so 'Newton' becomes 'notweN'. The built-in function enumerate() takes a sequence (e.g. a list) and generates a new sequence of the same length. Each element of the new sequence is a pair composed of the index (0, 1, 2,…) and the value from the original sequence: fruits = [&#39;apple&#39;, &#39;banana&#39;, &#39;grapes&#39;, &#39;pear&#39;] for position, name in enumerate(fruits): print(&quot;The &quot;, position, &quot;fruit is &quot;, name) ## The 0 fruit is apple ## The 1 fruit is banana ## The 2 fruit is grapes ## The 3 fruit is pear The function shuffle() in the random package rearranges a list in place (meaning it changes the original object, so you don’t have to use a fresh variable name. Use the enumerate() and random.shuffle() to mix up the list below and work out where the digit 100 appears in the list. big_numbers = list(range(1000) ) "],
["user-functions.html", "Chapter 7 User Functions 7.1 Composing Functions 7.2 Variables Inside and Outside Functions 7.3 Quiz", " Chapter 7 User Functions We’d like a way to package our code so that it is easier to reuse, and Python provides for this by letting us define things called ‘functions’ a shorthand way of re-executing longer pieces of code. Let’s start by defining a function fahr_to_celsius that converts temperatures from Fahrenheit to Celsius: def fahr_to_celsius(temp): return ((temp - 32) * (5/9)) The Blueprint for a Python Function The function definition opens with the keyword def followed by the name of the function (fahr_to_celsius) and a parenthesized list of parameter names (temp). The body of the function, the statements that are executed when it runs is indented below the definition line. The body concludes with a return keyword followed by the return value. When we call the function, the values we pass to it are assigned to those variables so that we can use them inside the function. Inside the function, we use a return statement to send a result back to whoever asked for it. Let’s try running our function. fahr_to_celsius(32) This command should call our function, using “32” as the input and return the function value. In fact, calling our own function is no different from calling any other function: print(&#39;freezing point of water:&#39;, fahr_to_celsius(32), &#39;C&#39;) ## freezing point of water: 0.0 C print(&#39;boiling point of water:&#39;, fahr_to_celsius(212), &#39;C&#39;) ## boiling point of water: 100.0 C We’ve successfully called the function that we defined, and we have access to the value that we returned. 7.1 Composing Functions Now that we’ve seen how to turn Fahrenheit into Celsius, we can also write the function to turn Celsius into Kelvin: def celsius_to_kelvin(temp_c): return temp_c + 273.15 print(&#39;freezing point of water in Kelvin:&#39;, celsius_to_kelvin(0.)) ## freezing point of water in Kelvin: 273.15 What about converting Fahrenheit to Kelvin? We could write out the formula, but we don’t need to. Instead, we can compose the two functions we have already created: def fahr_to_kelvin(temp_f): temp_c = fahr_to_celsius(temp_f) temp_k = celsius_to_kelvin(temp_c) return temp_k print(&#39;boiling point of water in Kelvin:&#39;, fahr_to_kelvin(212.0)) ## boiling point of water in Kelvin: 373.15 This is our first taste of how larger programs are built, we define basic operations, then combine them in ever-large chunks to get the effect we want. 7.2 Variables Inside and Outside Functions The function is insulated from the rest of the program. Things that happen in there don’t affect what goes on elsewhere. Meaning we can re-use variable names inside the function that we used elsewhere without polluting them. Look what happens when the following piece of code is run f = 0 k = 0 def f2k(f): k = ((f-32)*(5.0/9.0)) + 273.15 return k print( f2k(8) ) print( f2k(41) ) print( f2k(32) ) print(k) 259.81666666666666 287.15 273.15 0 k is 0 because the k inside the function f2k doesn’t know about the k defined outside the function. 7.3 Quiz “Adding” two strings produces their concatenation 'a' + 'b' is 'ab'. Write a function called fence that takes two parameters called original and wrapper and returns a new string that has the wrapper character at the beginning and end of the original. A call to your function should look like this: print(fence(&#39;name&#39;, &#39;*&#39;)) Note that return and print are not interchangeable.print is a Python function that prints data to the screen. It enables us, users, see the data. return statement, on the other hand, makes data visible to the program. Let’s have a look at the following function: def add(a, b): print(a + b) What will we see if we execute the following commands? A = add(7, 3) print(A) If the variable s refers to a string, then s[0] is the string’s first character and s[-1] is its last. Write a function called outer that returns a string made up of just the first and last characters of its input. A call to your function should look like this: print(outer(&#39;helium&#39;)) Rescaling an Array Write a function rescale that takes a list as input and returns a corresponding list of values scaled to lie in the range 0.0 to 1.0. (Hint: If L and H are the lowest and highest values in the original array, then the replacement for a value v should be (v-L) / (H-L). The max() function returns the biggest value in a list) Consider this code: a = 3 b = 7 def swap(a, b): temp = a a = b b = temp swap(a, b) print(a, b) Which of the following would be printed if you were to run this code? Why did you pick this answer? 7 3 3 7 3 3 7 7 "],
["using-packages.html", "Chapter 8 Using Packages 8.1 Using and Installing Packages. 8.2 The PyVCF Package 8.3 Quiz", " Chapter 8 Using Packages Packages are an important part of the Python ‘eco-system’ that let us use a wide variety of code written by other people. Good packages provide functions, objects and methods that make working in a particular problem domain a lot easier. 8.1 Using and Installing Packages. We’ve already seen how to load in packages using the import statement. Here we load the sys package which has methods for working with the underlying system - the platform is the name of the operating system this code is running on. import sys print( sys.platform ) ## darwin Some packages come as standard when Python is installed, some come from external sources and must be installed individually. There are multiple methods of installing packages. Assuming you set up Python using Anaconda for this book then you can use conda itself. Another more general way of installing packages is from PyPI, the Python Package Index. None of these are done from within Python itself, and must be done from the regular command-line. The general form is: conda install package_name pip install package_name 8.2 The PyVCF Package VCF files (variant call format) are files that describe SNPs and small indels in alignments from high-throughput sequencing data. The PyVCF package provides a lot of functionality for working with such files and the record they contain. 8.2.1 VCF files - a brief introduction A VCF file is a column format file where each row represents a SNP/Indel record and the columns represent the variables of things like Chromosome, Position, Reference Genome Allele, Alternative Genome Allele etc. Here’s what one record looks like. Table continues below CHROM POS ID REF ALT QUAL FILTER 20 14370 rs6054257 G A 29 PASS Table continues below INFO FORMAT NA00001 NA00002 NS=3;DP=14;AF=0.5;DB;H2 GT:GQ:DP:HQ 0|0:48:1:51,51 1|0:48:8:51,51 NA00003 1/1:43:5:.,. There’s a lot of information in that one record, and each file has many tens of thousands of records! !e wouldn’t want to try and process tens of thousands manually. Let’s look at loading in a file and looping through each record using the PyVCF package. We’ve already seen that packages have functions we can call, and that doing so can sometimes return objects of new types. We’ll use that pattern now to start processing a VCF file. 8.2.2 The vcf.Reader object The first package function we’ll need to use is vcf.Reader which opens and connects to a file but doesn’t do anything with it. It gives us a reader object we can use to access the file. We just need the file name that we wish to open. import vcf vcf_reader = vcf.Reader(open(&#39;/Users/macleand/Desktop/example.vcf&#39;, &#39;r&#39;)) Now we can go ahead and extract the VCF records by using the reader object we created in a loop for record in vcf_reader: print( record ) print(type(record)) ## Record(CHROM=20, POS=14370, REF=G, ALT=[A]) ## &lt;class &#39;vcf.model._Record&#39;&gt; ## Record(CHROM=20, POS=17330, REF=T, ALT=[A]) ## &lt;class &#39;vcf.model._Record&#39;&gt; ## Record(CHROM=20, POS=1110696, REF=A, ALT=[G, T]) ## &lt;class &#39;vcf.model._Record&#39;&gt; ## Record(CHROM=20, POS=1230237, REF=T, ALT=[None]) ## &lt;class &#39;vcf.model._Record&#39;&gt; ## Record(CHROM=20, POS=1234567, REF=GTCT, ALT=[G, GTACT]) ## &lt;class &#39;vcf.model._Record&#39;&gt; This does the code loop for every record in the file. 8.2.3 The vcf.Record object Every time we loop we get a new vcf.Record object. This is a special sort of object provided by the PyVCF package that represents the VCF record. We already saw how objects have methods - special functions that apply straight to the data in that object. PyVCF is no exception. As well as methods, objects can have properties called attributes. 8.2.4 Object Attributes Attributes of an object are different from functions of an object in that they tend to be things that just are rather than things that are computed. So a hypothetical shape object representing a geometric shape might have an attribute called sides. This wouldn’t need recomputing as it would be the same everytime. Attributes are easy to spot as they use the object dot . syntax, omitting the brackets at the end of the attribute name. Let’s examine that using the .POS attribute. vcf_reader = vcf.Reader(open(&#39;/Users/macleand/Desktop/example.vcf&#39;, &#39;r&#39;)) for record in vcf_reader: print( record.POS ) ## 14370 ## 17330 ## 1110696 ## 1230237 ## 1234567 Here we can see that we get the position of each SNP/Indel in the chromosome from .POS. Note that we had to redo the vcf_reader creation - this is because the vcf.Reader object has in a sense “got to the end” of the data the first time we used it. It needs re-winding to the start and one way to do that is to recreate it and thereby reset it. 8.2.4.1 Finding the methods and attributes an object has If we want to find out what methods or attributes an object has we can use the dir() function which gives us these for an object. print( dir(vcf_reader) ) ## [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dict__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__next__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;__weakref__&#39;, &#39;_alt_pattern&#39;, &#39;_column_headers&#39;, &#39;_format_cache&#39;, &#39;_header_lines&#39;, &#39;_map&#39;, &#39;_parse_alt&#39;, &#39;_parse_info&#39;, &#39;_parse_metainfo&#39;, &#39;_parse_sample_format&#39;, &#39;_parse_samples&#39;, &#39;_prepend_chr&#39;, &#39;_reader&#39;, &#39;_row_pattern&#39;, &#39;_sample_indexes&#39;, &#39;_separator&#39;, &#39;_tabix&#39;, &#39;alts&#39;, &#39;contigs&#39;, &#39;encoding&#39;, &#39;fetch&#39;, &#39;filename&#39;, &#39;filters&#39;, &#39;formats&#39;, &#39;infos&#39;, &#39;metadata&#39;, &#39;reader&#39;, &#39;samples&#39;] So the list is really large! Some methods and attributes begin with _ underscore characters. By convention these are things that are used internally by the object - so you don’t need to worry about those. We can filter the ones we can use, by building a list of ones that don’t start with ’_’ attrs = dir(vcf_reader) keepers = [] for a in attrs: if not a.startswith(&quot;_&quot;): keepers.append(a) print( keepers ) ## [&#39;alts&#39;, &#39;contigs&#39;, &#39;encoding&#39;, &#39;fetch&#39;, &#39;filename&#39;, &#39;filters&#39;, &#39;formats&#39;, &#39;infos&#39;, &#39;metadata&#39;, &#39;reader&#39;, &#39;samples&#39;] This is a much shorter list. You can see the online documentation for the object here https://pyvcf.readthedocs.io/en/latest/API.html#vcf-reader Pretty much all objects and packages will have some online documentation so you can usually find something. Sometimes it’s a bit sparse, unfortunately. 8.3 Quiz Using PyVCF, calculate how many of the records are SNPs and how many are Indels. Use the documentation to see how you might achieve this - https://pyvcf.readthedocs.io/en/latest/API.html#vcf-model-record For each SNP, work out whether it’s an A-G or C-T, a so-called transition. Would your method be efficient on a file of thousands of SNPS? Which record has the greatest number of alleles? Would your method be efficient on a file of thousands of SNPs/Indels? How many alternative alleles are heterozygous, for each record? "],
["putting-code-into-scripts.html", "Chapter 9 Putting code into scripts 9.1 The Script Header 9.2 The Filename Extension 9.3 Running a Python script 9.4 Getting Options from the Command Line 9.5 Quiz", " Chapter 9 Putting code into scripts Scripts are files full of code that has been put together in order to do a particular task. The idea being that the code will get re-run many times and not just as a one off. Building a script is usually pretty easy - just type the code in to a text file. You’ll need a text editor, a program that deals with text but not in the same way as a word processor. Many such programs are available, try the options below TextMate (macOS) https://macromates.com/ Atom (macOS/Windows) https://atom.io/ Notepad++ (Windows) https://notepad-plus-plus.org/ 9.1 The Script Header Most Python scripts have this on the first line #!/usr/bin/env python This is a Unix/Linux convention that affects how those systems interpret the file. Leave it in for convention’s sake. 9.2 The Filename Extension By convention, Python scripts end in the extension, .py. So if we have the following in a file called hello_world.py, we have a Python script. #!/usr/bin/env python print(&quot;Hello, World!&quot;) 9.3 Running a Python script Once created, the script itself is run from the python command on the command line. python is just a regular program that accepts a python script filename as its argument and runs the code in the script. Here’s an example terminal session that runs a script. Last login: Thu Dec 6 10:59:32 on ttys000 ~/Desktop macleand$ python hello_world.py Hello, World! ~/Desktop macleand$ 9.4 Getting Options from the Command Line A good reason for creating scripts is because you want to be able to re-run the code in them. Sometimes you’ll want to change some aspect or behaviour of the code according to settings given on the command-line. For example, you might want to work on a different input file each time. We can access the text from the command-line in the script, using the sys.argv attribute in the sys module. Imagine the command line python my_script.py OPTION_1 option_2 We access it like this #!/usr/bin/env python import sys print( sys.argv ) [&#39;my_script.py&#39;, &#39;OPTION_1&#39;, &#39;option_2&#39;] The sys.argv attribute gives us a list of the command line options. The first item in the list is the script name, the options come after that. So we can access the options by indexing the sys.argv list python my_script.py OPTION_1 option_2 #!/usr/bin/env python import sys first_option = sys.argv[1] second_option = sys.argv[2] print(second_option, first_option) option_2 OPTION_1 9.5 Quiz Create a script that writes ‘Hello, World!’ to the screen. Run it. Create a script that takes one argument and prints that to the screen as You said.. &lt;argument&gt; - replacing &lt;argument&gt; with the value you give on the command line. Create a script that takes two numbers from the command line and adds them together and prints the result. "],
["putting-it-all-together.html", "Chapter 10 Putting It All Together 10.1 A Challenge in Python", " Chapter 10 Putting It All Together 10.1 A Challenge in Python This file ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR020/SRR020192/SRR020192.fastq.gz contains next generation sequencing reads in fastq format. Write a Python script that use the BioPython package to Count the reads in the fastq file Filter out low-quality reads from the fastq file Calculate how many reads are retained Use at least one user-defined function Acknowledgements Some of the quizzes and examples in this book particularly those in Chapters 3 to 7 are taken from the Software Carpentry lesson on Programming in Python http://swcarpentry.github.io/python-novice-inflammation/. Other examples in Chapter 9 and 10 are taken from the Biopython tutorial http://biopython.org/DIST/docs/tutorial/Tutorial.html and the PyVCF tutorial https://pyvcf.readthedocs.io/.These are re-used under their respective licences. The rest of the materials are licensed under Creative Commons 0. "]
]
